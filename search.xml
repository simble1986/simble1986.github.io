<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[美签记录]]></title>
    <url>%2Fpost%2Ffbe9394a.html</url>
    <content type="text"><![CDATA[记第一次拿到十年美签 时间 提交DS160: 2018-07-08 预约面签时间: 2018-07-27 前面排队人太多 Issued: 2018-07-30 收到护照: 面签问题 你去美国干什么？ 要去美国多久？ 你是做什么工作的？ 你们公司是做什么的？ 你是一个人去么？ “你通过了！”]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>visa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Openstack学习笔记1]]></title>
    <url>%2Fpost%2F9b5fb1d1.html</url>
    <content type="text"><![CDATA[该系列用来记录本人使用Openstack的一些笔记和心得 Openstack一些理解 服务说明 keystone - 必选 认证服务，是其他所有服务的基础 glance - 必选 镜像服务，用来存储镜像文件，如iso, vmdk, qcow2等 nova - 必选 计算服务，包括计算，调度，管理，api等，是openstack的核心服务 neutron - 必选 网络服务 horizon - 可选（推荐选择） 管理界面，图形化管理界面，方便使用 cinder - 可选 块存储服务，用来创建虚拟机的磁盘 一些理解 openstack可以理解为插件型的，灵活就体现于此。 计算服务，控制节点可以只做计算的调度，管理，也可以在控制节点上启动计算服务 同样，可以在任意一个节点上起块存储服务 关于网络 刚开始的时候很疑惑，为什么每个计算节点上都要配置一个额外的网卡，并将其连在一起 需要说明的是： 虚拟机的第一个网口是openstack的各个节点用来通信的网卡 第二个网口是用来实现在openstack上启动的实例彼此通信的（即东西向流量） 也可以不用第二个网口，这时，两个实例可以通过基于第一个网口之间建立的隧道进行通信 如果要让实例可以访问外网，则需要为其分配专门的访问外网的网口 openstack并不直接管理网口或网桥，要么通过linux bridge，或者是openvSwitch 在openstack的UI上看到的网口，都是代号 测试环境准备 两台虚拟机（当然也可以all in one） 硬件准备 每台虚拟机应包含 虚机可上网 另外包含一张额外的网卡 内存尽量多（8G） CPU尽量多（8 cpus） controller硬盘稍微大一些 基本准备 Ubuntu16.04 + Q版本（Queens） 配置NTP 安装Openstack基础包 准备仓库 12# apt install software-properties-common# add-apt-repository cloud-archive:queens 安装openstack包 123$ apt update$ apt upgrade #经实际测试，如果用apt dist-upgrade可能会出现问题，安装的不是最新的包$ apt install python-openstackclient controller controller上需要安装的东西最多 依赖 数据库: MariaDB 消息队列: RabbitMQ 服务及身份认证: Memcached etcd openstack服务 认证服务: keystone 镜像服务: glance 计算服务（指计算的调度，管理，api等服务）: nova 网络服务（网络管理，调度等服务）: neutron 管理界面: horizon 块存储服务（可选）: cinder compute 计算节点相对来说简单了很多 openstack服务 计算服务（专指计算服务）: nova-compute 网络服务: neutron 可在controller上同样起计算服务 详细安装过程可参看官方文档]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用markdown写PPT]]></title>
    <url>%2Fpost%2F4f712e63.html</url>
    <content type="text"><![CDATA[自打接触Markdown以来，深深的爱上了这种格式的书写，先是弄网站，然后又弄电子书。最近要给新员工培训，要准备4个PPT，于是就想有没有直接用md来写PPT的呢？上网一搜，还真有。 有Reveal.js, LandSlide, GitPitch等，但也许是我研究的不深吧，gitpitch是在线的，LandSlide要用pip来安装。Reveal.js倒是之前见team里的大神有写过，但现在好像变成了slides了，也是在线的。最终，主角出场，我选择了Marp。 优点 书写简单 提供两套模版 可实时预览 只需要一个md文件即可，不需要其他诸如yaml之类的东西 支持Mac，Win和Linux 缺点 没有动画 只能导出为pdf格式，不能生成PPT格式 仅支持基础的markdown语法 虽然有着上面的缺点，然而，对于写技术类PPT，我觉得够用了 用法 Marp提供两套主题，都说专治选择障碍。特别是默认主题，简直是选择障碍患者的福音。 下载完安装后，两个例子中已经有比较基本的说明了。但有一些东西还是很容易被忽略。 设置页码 页码是可以随时开启，随时关闭的。 1&lt;!-- page_number: true --&gt; 在任意页输入以上代码就可以开启，但如果你要在哪页关闭显示页码，可以用false 背景设置 因为只有两套模版，所以，想要好看点，还是需要一些背景图片的。刚开始我只知道用![bg](aaa.png)的方式引入背景，但后来发现背景图片其实是和背景主题叠加了的。 后来细细看了文档才发现，原来可以用开关开启，还可以设置背景的大小 1![bg original 70%](aaa.png) 使用了original之后，背景就变成了纯图片，而70%则可以指定图片大小。 当然，更有趣的是，可以用多个背景并排的方式来完成部分植入。 比如： 则是用如下代码完成 123456![bg 450% original](robot2.png)![bg]()![bg]()![bg]()![bg]()![bg 450% original](robot2.png) 还有一个有意思的是，如果不设置图片的比例，那么会按照扩充满整个屏幕来设置，但如果设置比例，如上面的代码，则100%是整个页面宽度/6之后的图片大小。 当然，灵活运用这一个特性，也能带来很多意想不到的效果。 emoji 值得一提的是Marp的emoji表情选择的很是我喜欢的那种，而且可以按照段落来调整大小 比如： 1234# :cat:## :fish:### :tiger:#### :bird: 表情的大小会随着段落比较而变化。还是很不错的。 另外，似乎软件的作者正在开发新的软件，很是期待 🐱]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04安装Open vSwitch]]></title>
    <url>%2Fpost%2Fb2c6ed30.html</url>
    <content type="text"><![CDATA[环境准备 获取安装包 1git clone https://github.com/openvswitch/ovs.git 安装必要的依赖 1apt install autoconf libtool make libssl-dev libcap-ng-dev 安装 当使用源代码时，需要自己创建configure脚本 1$ ./boot.sh 配置并开启内核模块 1$ ./configure --prefix=/usr --localstatedir=/var --sysconfdir=/etc --with-linux=/lib/modules/$(uname -r)/build 安装 12$ make$ make install 安装内核模块 该步骤可能会报错，请参看后文 1$ make modules_install 官方安装文档中提到，你有可能之前已经安装了ovs的模块，为了确保使用的是你刚才编译的，则需要在/etc/depmod.d/中添加如下内容 1234567$ config_file=&quot;/etc/depmod.d/openvswitch.conf&quot;$ for module in datapath/linux/*.ko; do modname=&quot;$(basename $&#123;module&#125;)&quot; echo &quot;override $&#123;modname%.ko&#125; * extra&quot; &gt;&gt; &quot;$config_file&quot; echo &quot;override $&#123;modname%.ko&#125; * weak-updates&quot; &gt;&gt; &quot;$config_file&quot; done$ depmod -a 加载内核模块 1$ /sbin/modprobe openvswitch 验证 123456789$ /sbin/lsmod | grep openvswitchopenvswitch 303104 0tunnel6 16384 1 openvswitchnf_nat_ipv6 16384 1 openvswitchnf_defrag_ipv6 36864 2 openvswitch,nf_conntrack_ipv6nf_nat_ipv4 16384 2 openvswitch,iptable_natnf_nat 28672 6 nf_nat_redirect,openvswitch,nf_nat_ipv4,nf_nat_ipv6,xt_nat,nf_nat_masquerade_ipv4nf_conntrack 106496 11 xt_CT,openvswitch,nf_nat,nf_nat_ipv4,nf_nat_ipv6,xt_conntrack,nf_nat_masquerade_ipv4,nf_conntrack_netlink,xt_connmark,nf_conntrack_ipv4,nf_conntrack_ipv6libcrc32c 16384 2 raid456,openvswitch 启动服务 官方说明中提到有一个ovs-ctl的命令，然而，我安装完之后并没有这个命令。可能官方文档比较老了吧。 创建必要的目录 123$ mkdir -p /etc/openvswitch$ mkdir -p /var/log/openvswitch$ mkdir -p /var/run/openvswitch 配置ovsdb-server 从源文件目录创建conf.db 12ovs$ ovsdb-tool create /etc/openvswitch/conf.db \ vswitchd/vswitch.ovsschema 配置 123456ovsdb-server --remote=punix:/var/run/openvswitch/db.sock \ --remote=db:Open_vSwitch,Open_vSwitch,manager_options \ --private-key=db:Open_vSwitch,SSL,private_key \ --certificate=db:Open_vSwitch,SSL,certificate \ --bootstrap-ca-cert=db:Open_vSwitch,SSL,ca_cert \ --pidfile --detach --log-file 初始化数据库 1ovs-vsctl --no-wait init 启动ovs进程 1ovs-vswitchd --pidfile --detach --log-file 验证 创建bridge 1$ ovs-vsctl add-br br0 为br0添加接口 1$ ovs-vsctl add-port br0 eth1 查看配置 1$ ovs-vsctl show 问题及解决 安装内核模块时出现如下错误，忽略即可（我还以为很严重，搜了一阵，发现不用管） 123456789101112131415161718192021222324252627282930313233343536373839$ make modules_installcd datapath/linux &amp;&amp; make modules_installmake[1]: Entering directory &apos;/root/ovs/datapath/linux&apos;make -C /lib/modules/4.4.0-127-generic/build M=/root/ovs/datapath/linux modules_installmake[2]: Entering directory &apos;/usr/src/linux-headers-4.4.0-127-generic&apos; INSTALL /root/ovs/datapath/linux/openvswitch.koAt main.c:222:- SSL error:02001002:system library:fopen:No such file or directory: bss_file.c:175- SSL error:2006D080:BIO routines:BIO_new_file:no such file: bss_file.c:178sign-file: certs/signing_key.pem: No such file or directory INSTALL /root/ovs/datapath/linux/vport-geneve.koAt main.c:222:- SSL error:02001002:system library:fopen:No such file or directory: bss_file.c:175- SSL error:2006D080:BIO routines:BIO_new_file:no such file: bss_file.c:178sign-file: certs/signing_key.pem: No such file or directory INSTALL /root/ovs/datapath/linux/vport-gre.koAt main.c:222:- SSL error:02001002:system library:fopen:No such file or directory: bss_file.c:175- SSL error:2006D080:BIO routines:BIO_new_file:no such file: bss_file.c:178sign-file: certs/signing_key.pem: No such file or directory INSTALL /root/ovs/datapath/linux/vport-lisp.koAt main.c:222:- SSL error:02001002:system library:fopen:No such file or directory: bss_file.c:175- SSL error:2006D080:BIO routines:BIO_new_file:no such file: bss_file.c:178sign-file: certs/signing_key.pem: No such file or directory INSTALL /root/ovs/datapath/linux/vport-stt.koAt main.c:222:- SSL error:02001002:system library:fopen:No such file or directory: bss_file.c:175- SSL error:2006D080:BIO routines:BIO_new_file:no such file: bss_file.c:178sign-file: certs/signing_key.pem: No such file or directory INSTALL /root/ovs/datapath/linux/vport-vxlan.koAt main.c:222:- SSL error:02001002:system library:fopen:No such file or directory: bss_file.c:175- SSL error:2006D080:BIO routines:BIO_new_file:no such file: bss_file.c:178sign-file: certs/signing_key.pem: No such file or directory DEPMOD 4.4.0-127-genericmake[2]: Leaving directory &apos;/usr/src/linux-headers-4.4.0-127-generic&apos;depmod `sed -n &apos;s/#define UTS_RELEASE &quot;\([^&quot;]*\)&quot;/\1/p&apos; /lib/modules/4.4.0-127-generic/build/include/generated/utsrelease.h`make[1]: Leaving directory &apos;/root/ovs/datapath/linux&apos;]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>ovs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gitbook+gitlab发布私有的图书仓库]]></title>
    <url>%2Fpost%2F51748f3c.html</url>
    <content type="text"><![CDATA[近期带着一些同事学习python，开始用markdown的格式写了很多练习题，一直有想法将其发布成一本电子书在公司内部分享。但由于有些内容可能涉及公司相关，无法直接对外发布。而公司内部自建了一个gitlab服务器，一直用于托管一些不是很重要的代码。所以，便有了将markdown托管到gitlab上，然后使用gitbook在内部进行发布。 另一方面，由于最近痴迷于Docker，所以，也同样将gitbook打包成docker image，用于快速发布。这篇文章主要用于记录整个操作过程。 gitbook+docker 本地安装 可参看gitbook的官方文档 环境需求 gitbook需要nodejs环境 NodeJS (v4.0.0 and above is recommended) 安装gitbook-cli 1npm install gitbook-cli -g 创建一本书 当使用gitlab时，可跳过此步骤 创建存放书籍的目录 1$ mkdir mybook 初始化 1$ gitbook init 初始化完成后，将生成SUMMARY.md和README.md 插件安装 如果没有生成book.json，可自行创建 12345678910111213&#123;&quot;root&quot;: &quot;./&quot;,&quot;title&quot;: &quot;mybook&quot;,&quot;head_title&quot;: &quot;My first book&quot;,&quot;description&quot;: &quot;test with gitbook&quot;,&quot;author&quot;: &quot;myname&quot;,&quot;output.name&quot;: &quot;practice&quot;,&quot;gitbook&quot;: &quot;&gt;= 3.0.0&quot;,&quot;language&quot;: &quot;zh-hans&quot;,&quot;plugins&quot;: [ ] 将插件在plugins字段中进行声明后，执行以下命令进行安装 1$ gitbook install 预览和发布自己的书 1$ gitbook serve 随后可登陆http://localhost:4000来预览自己的书 docker镜像 其实在docker hub上搜索便可以得到gitbook的镜像，但本着学习的态度，还是自己动手练习制作自己的docker镜像。 由于nodejs有官方提供的docker镜像，所以，一切变得很简单 Dockerfile 12345678910FROM node:8-alpineMAINTAINER Bo Qi &lt;simble1986@gmail.com&gt;RUN npm install gitbook-cli -g &amp;&amp; npm install &amp;&amp; gitbook installWORKDIR /bookEXPOSE 4000 35729CMD gitbook install &amp;&amp; gitbook serve 编译docker镜像 1$ docker build --tag mygitbook . 书的结构 当使用gitbook init后会在当前目录生成两个文件：README.md和SUMMARY.md. 其中，README.md用来对本书进行一些说明 而SUMMARY.md则用来创建目录结构。 SUMMARY.md 1234567891011121314151617# Summary* [介绍](README.md)* [Git使用](gitSetup.md)* [Python基础](part1/README.md) * [练习1-列表](part1/1.md) * [练习2-字典](part1/2.md) * [练习3-数据结构嵌套](part1/3.md) * [练习4-运算符](part1/4.md) * [练习5-逻辑控制](part1/5.md) * [练习6-异常处理](part1/6.md) * [练习7-函数](part1/7.md) * [练习8-文件操作](part1/8.md) * [轻松一刻-猜数字游戏](part1/happy1.md) * [练习9-类.1](part1/9.md) * [练习10-类.2](part1/10.md) * [练习11-类的继承](part1/11.md) book.json 需要自己创建book.json 12345678910111213141516171819202122232425262728293031323334353637&#123; "root": "./", "title": "练习python", "head_title": "通过练习的方式来学习python", "description": "通过小练习一点一点熟悉python", "author": "myname(simble1986@gmail.com)", "output.name": "通过练习学脚本", "gitbook": "3.2.3", "language": "zh-hans", "links" : &#123; "sidebar" : &#123; "Home" : "http://www.simble.site" &#125; &#125;, "plugins": [ "autotheme", "prism", "prism-themes", "-highlight", "-search", "search-pro", "emphasize", "splitter", "tbfed-pagefooter", "toggle-chapters", "codeblock-filename", "ace", "simple-page-toc", "edit-link", "copy-code-button", "alerts", "anchor-navigation-ex", "theme-comscore" ]&#125; git-lab归档 在gitlab上创建自己的project并归档 在服务器上用docker启动预览 从gitlab上clone书的结构 启动docker并挂载gitbook的目录到docker中 1$ docker run -d -p 80:4000 -v /mybook:/book mygitbook 插件及说明 非常感谢Zhangjikai的插件说明文档，然后我发现Zhangjikai和我一样使用了Hexo搭建了自己的blog，并且同样适用了Next的主题]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python virtenv环境搭建]]></title>
    <url>%2Fpost%2F4926e490.html</url>
    <content type="text"><![CDATA[近期由于组内测试框架更新频繁，且由于框架采用了插件形式，安装包很多。当使用同一台服务器来安装时，可能会导致生产环境破坏。为此，必须采用virtenv方式。 virtualenv的环境建立并不复杂，但每次都需要去查一番。特此记录 安装 安装virtualenv python2.7 1pip install virtualenv python3 1pip3 install virtualenv 使用 创建工作目录 12root@vm1:/home/test# mkdir myprojectroot@vm1:/home/test# cd myproject 创建独立的python运行环境 1234root@vm1:/home/test# virtualenv venvNew python executable in /home/test/myproject/venv/bin/pythonInstalling setuptools, pip, wheel...done.root@vm1:/home/test# 引用新的环境变量 12root@vm1:/home/test# source venv/bin/activate(venv)root@vm1:/home/test# 开始使用 1(venv)root@vm1:/home/test# pip install docker 退出当前venv环境 12(venv)root@vm1:/home/test# deactivateroot@vm1:/home/test# 一个小问题 git clone时遇到server certificate verification failed. CAfile: /etc/ssl/certs/ca-certificates.crt CRLfile: none的解决方法 1export GIT_SSL_NO_VERIFY=1]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker API一种连接到PTY的交互方法]]></title>
    <url>%2Fpost%2Fb18ab8ad.html</url>
    <content type="text"><![CDATA[折腾了一周多，终于搞定了在docker的python API下，当执行exec_run时，如何连接container的PTY。 当弄明白之后，才发现原来是那么简单。之前几乎搜遍了google和百度，都没有找到相关的文章 前言 这两年，docker的发展如火如荼，作为网络测试，我们也在尝试着将docker引入测试中，来更多的模拟真实用户，并实现自动化。 Pexpect是一个非常强大且好用的工具，当需要与设备和PC连接时，基本上都会用到。而之前都直接使用spawn一个命令行来进行连接 本篇博文将介绍一种使用pexpect的fdspawn，通过socket方式连接到container的方法，以便与远程的container进行交互 自动化思路 client通过python API连接到docker 创建一个container并保持运行 使用exec_run()新建一个连接，运行/bin/bash，并开启socket方式 使用pexpect的fdspawn连接exec_run()返回的socket 环境准备 Docker开启remote API 参见之前博文 Docker Client 安装必要的包 12$ pip install docker$ pip install pexpect 开始使用 创建container 123&gt;&gt;&gt; import docker&gt;&gt;&gt; client=docker.DockerClient(base_url='tcp://10.0.0.10:1234')&gt;&gt;&gt; c1 = client.containers.run("ubuntu", detach=True, tty=True) 连接container 123456&gt;&gt;&gt; res = c1.exec_run("/bin/bash", socket=True, stdin=True, tty=True)&gt;&gt;&gt; resExecResult(exit_code=None, output=&lt;socket object, fd=15, family=1, type=1, protocol=0&gt;)&gt;&gt;&gt; sock = res.output&gt;&gt;&gt; sock&lt;socket object, fd=15, family=1, type=1, protocol=0&gt; 使用pexpect连接 1234567891011&gt;&gt;&gt; import pexpect.fdpexpect&gt;&gt;&gt; session=pexpect.fdpexpect.fdspawn(sock.fileno(),timeout=10)&gt;&gt;&gt; &gt;&gt;&gt; session.send("ls\n")3&gt;&gt;&gt; session.expect("#")0&gt;&gt;&gt; session.before' ls\r\n\x1b[0m\x1b[01;34mbin\x1b[0m \x1b[01;34mdev\x1b[0m \x1b[01;34mhome\x1b[0m \x1b[01;34mlib64\x1b[0m \x1b[01;34mmnt\x1b[0m \x1b[01;34mproc\x1b[0m \x1b[01;34mrun\x1b[0m \x1b[01;34msrv\x1b[0m \x1b[30;42mtmp\x1b[0m \x1b[01;34mvar\x1b[0m\r\n\x1b[01;34mboot\x1b[0m \x1b[01;34metc\x1b[0m \x1b[01;34mlib\x1b[0m \x1b[01;34mmedia\x1b[0m \x1b[01;34mopt\x1b[0m \x1b[01;34mroot\x1b[0m \x1b[01;34msbin\x1b[0m \x1b[01;34msys\x1b[0m \x1b[01;34musr\x1b[0m\r\n\x1b]0;root@6a097ddbe55d: /\x07root@6a097ddbe55d:/'&gt;&gt;&gt; session.after'#'&gt;&gt;&gt; 注意事项 在使用exec_run()执行开启命令时，需要指定stdin=True，否则，pexpect的send()将无法将命令发送至container 同样，在使用exec_run()时，需要指定tty=True，否则，将没有命令行提示符，无法进行匹配]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>pexpect</tag>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dockerpty使用]]></title>
    <url>%2Fpost%2F1c49a9aa.html</url>
    <content type="text"><![CDATA[本篇博客将介绍在使用docker API时，如何监管container的PTY实现交互 问题引入 docker官方已经提供了API用来管理client，container，image，network等，基本的操作覆盖了docker CLI相关功能，但docker的API现在只能使用exec_run来执行一条命令，中间无法进行交互，希望能有一个类似于-it的方式来完成交互操作。 经过几天的学习和测试，发现其实docker的containers.run()和containers.exec_run()都是可以设置stdin=True, tty=True。但开启这些之后，将返回一个socket，需要自己来进行处理。 google大法后，找到了一个dockerpty的python lib，可以完成这件事情 环境搭建 根据dockerpty的github上提到的安装过程，只需要pip install dockerpty即可完成安装。 但源码已经有两年没有更新了，该版本无法在新的docker API上正常工作 fork了工程后，对其中的代码涉及到的docker API进行更新后，测试可以正常工作，最新的代码已经上传到git上simble1986/dockerpty 依赖 原有的project上提到依赖的docker api为docker-py&gt;=0.3.2，但docker的python API已经更新 安装docker API 1pip install docker 安装步骤 获取源码 1git clone https://github.com/simble1986/dockerpty.git 安装 123$ pip uninstall dockerpty$ cd dockerpty$ python setup.py install 相关API 参看docker官方API文档，以下主要对container相关参数加以说明 tty (bool) – Allocate a pseudo-TTY. stdin_open (bool) – Keep STDIN open even if not attached. 基本使用 连接client 1234567root@slt-docker:/home/bqi# pythonPython 2.7.12 (default, Dec 4 2017, 14:50:18)[GCC 5.4.0 20160609] on linux2Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; import docker&gt;&gt;&gt; import dockerpty&gt;&gt;&gt; client=docker.from_env() 注： 支持远程API 创建container 1&gt;&gt;&gt; test1 = client.containers.create("ubuntu","/bin/bash",tty=True,stdin_open=True) 使用dockerpty 123456&gt;&gt;&gt; dockerpty.start(client,test1)root@d6ddcf619602:/# lsbin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr varroot@d6ddcf619602:/# exitexit&gt;&gt;&gt;]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>dockerpty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker中无密码apt安装mysql]]></title>
    <url>%2Fpost%2F70cf198a.html</url>
    <content type="text"><![CDATA[问题出现 Linux在第一次安装有些软件时会有交互的输入的需求，比如mysql在首次安装时需要设置root的密码。这在正常配置过程中没什么问题，但在使用DockerFile创建docker镜像时，则遇到了麻烦。 解决思路 如果将安装好的mysql-server使用apt remove从系统中卸载后，再次重新安装，则不再需要输入密码。另外当安装完一些软件后，可以使用dpkg-config来重新配置。 这样，就可以在安装软件前先对系统做好相关配置。接下来，就是需要获取软件的必要配置项 获取软件必要配置项 下载软件包 可以通过网上搜索方式下载相关的deb包，但众所周知，Linux的软件包版本多，很多情况下并不知道需要安装哪个版本。但可以使用apt来下载相应的软件包 1$ apt-get -d install -y mysql-server 使用apt-get的-d参数，将只会下载，不进行安装。下载完毕后，软件包位于/var/cache/apt/archives目录下。 获取配置项 进入软件包的存放目录，然后执行 1dpkg-preconfigure mysql-server-5.1_5.1.49-3_amd64.deb 使用debconfig-show来查看相应的配置项 12345$ debconf-show mysql-server mysql-server/root_password: (password omitted) mysql-server/root_password_again: (password omitted) mysql-server/error_setting_password: ... 可以看到，有两项是必须配置的：mysql-server/root_password和mysql-server/root_password_again 预配置 创建配置文件 在合适的目录下创建一个文件，例如mysql-passwd，输入以下内容 12debconf mysql-server/root_password password 123456debconf mysql-server/root_password_again password 123456 加载配置 1$ debconf-set-selections mysql-passwd 测试结果 再次安装mysql-server，将不再需要输入密码 1$ apt-get install -y mysql-server DockerFile处理 DockerFile应当尽量避免不需要的操作，所以，获取配置项的操作可以提前在实验环境中完成。 可将获取的命令行保存为本地文件，使用时copy过去。 12COPY ./mysql-passwd /tmp/mysql-passwdRUN apt-get update &amp;&amp; debconf-set-selections /tmp/mysql-passwd &amp;&amp; apt-get install -yqq mysql-server &amp;&amp; rm -rf /var/lib/apt/lists/* 或者是在DockerFile中直接生成，这时则可以将mysql passwd设置为参数 12RUN echo debconf mysql-server/root_password password 123456 &gt; /tmp/mysql-passwd &amp;&amp; echo debconf mysql-server/root_password_again password 123456 &gt;&gt; /tmp/mysql-passwdRUN apt-get update &amp;&amp; debconf-set-selections /tmp/mysql-passwd &amp;&amp; apt-get install -yqq mysql-server &amp;&amp; rm -rf /var/lib/apt/lists/*]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>DockerFile</tag>
        <tag>mysql-server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Next上开启Valine评论系统]]></title>
    <url>%2Fpost%2Fa072bce6.html</url>
    <content type="text"><![CDATA[朋友之前问怎么没有开评论系统，倒不是不想开，而是刚开始建站的时候浏览了好多博文，似乎很多原来的接口都在hexo不太好用了。特别是很多博文都是两年前写的，当然，大多数其他功能都没问题 简介 Valine Valine是一款基于Leancloud的快速、简洁且高效的无后端评论系统。 Leancloud 我的理解，Leancloud相当于是一个数据托管平台，可以帮助应用存储相关数据。Valine主要用到的是其中的数据存储——comments 环境说明 使用了最新版的Hexo以及最新版的Next主题 获取AppID 注册Leancloud 访问Leancloud，点击免费试用就会跳转到注册/登陆页面。当前支持通过Github，Weibo以及QQ进行注册 注册完后需要验证邮箱 创建应用 访问控制台，在控制台中创建新应用 获取应用Key 点击新创建的应用——设置——应用Key，保存页面上的App ID以及App Key以备后续使用 配置Valine 在最新版的Next主题中，已经合入了Valine的配置代码，使得配置起来非常快捷。访问Hexo中使用Valine，点击merged，会跳转到Next主题的merge历史 检查相关文件 可以再次检查并确认主题配置文件_config.xml，layout/_macro/post.swig和layout/_third-party/comments/valine.swig是否都已经合入了相关代码 配置AppKey 编辑主题配置文件_config.xml中的valine部分内容 12345678910valine: enable: true appid: $Your APP ID # your leancloud application appid appkey: $Your APP Key # your leancloud application appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: 随便说些什么吧 # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size 重新生成页面 执行命令，重新生成并部署 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 到这里，查看页面已经可以看到评论系统 创建留言页面 可以为站点创建一个单独的留言板页面 创建页面 1$ hexo new page guestbook 配置主题 修改主题配置文件 在主题配置文件_config.xml的menu字段新增guestbook字段 12345678910menu: home: / || home tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat about: /about/ || user guestbook: /guestbook/ || comments 可以访问fontawesome选择自己喜欢的图标来作为留言板的图标 本地化处理 编辑对应语言的配置文件themes/next/languages/zh-CN.yml，在menu中增加guestbook的中文 1234567891011menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益 404 guestbook: 留言 编辑页面 编辑之前生成的guestbook页面 123456---title: 留言板date: 2018-03-26 23:36:19comments: true---&lt;center&gt;既然来了，就是一种缘分，留下点什么吧:cat:&lt;/center&gt; 重新部署之后就可以看到留言板了 😃 清除测试留言 为了确保留言功能已经正常工作，都会测试一下。测试完毕后，可以通过Leancloud的控制台清除测试数据 点击myblog——存储——Comments，即可查看当前留言，选中测试时的留言，删除即可]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>Next</tag>
        <tag>Valine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Ubuntu 16.04上开启Docker的Remote API]]></title>
    <url>%2Fpost%2F3e41aa59.html</url>
    <content type="text"><![CDATA[由于自动化的考虑，需要用docker的remote API，尝试了多种方法，最终才找到了可行的方法 可行的方法 编辑/lib/systemd/system/docker.service 1$ vim /lib/systemd/system/docker.service 修改ExecStart的参数 1ExecStart=/usr/bin/dockerd -H fd:// -H tcp://0.0.0.0:2375 随后执行service docker restart时会提示Warning: docker.service changed on disk. Run 'systemctl daemon-reload' to reload units.则表示配置成功 1systemctl daemon-reload 重启docker服务 1service docker restart 测试是否成功 12$ curl http://localhost:2375/containers/json[&#123;"Id":"30c8e35f1292421d11f6b09385a4fc980d6abaca591d0f52b18dbad8e4f5be04","Names":["/clever_murdock"],"Image":"portainer/portainer","ImageID":"sha256:a8f2aeb34cf69178be1d152759fb17ccff7915faf750c82cd7d1851b12ec7b37","Command":"/portainer","Created":1520845664,"Ports":[&#123;"IP":"0.0.0.0","PrivatePort":9000,"PublicPort":9000,"Type":"tcp"&#125;],"Labels":&#123;&#125;,"State":"running","Status":"Up 13 minutes","HostConfig":&#123;"NetworkMode":"default"&#125;,"NetworkSettings":&#123;"Networks":&#123;"bridge":&#123;"IPAMConfig":null,"Links":null,"Aliases":null,"NetworkID":"78fa057306e70838bab1e18359c86bd8eff7de2285c351784ad951cd7a73f8d1","EndpointID":"e99ca98169320155c8833a8746be7d0e1c8d98186c75fba9d9bf2486367a4e00","Gateway":"172.17.0.1","IPAddress":"172.17.0.2","IPPrefixLen":16,"IPv6Gateway":"","GlobalIPv6Address":"","GlobalIPv6PrefixLen":0,"MacAddress":"02:42:ac:11:00:02","DriverOpts":null&#125;&#125;&#125;,"Mounts":[&#123;"Type":"bind","Source":"/opt/portainer","Destination":"/data","Mode":"","RW":true,"Propagation":"rprivate"&#125;,&#123;"Type":"bind","Source":"/var/run/docker.sock","Destination":"/var/run/docker.sock","Mode":"","RW":true,"Propagation":"rprivate"&#125;]&#125;] 不可行的方法 同时列出在Ubuntu上不可行的方法 修改/etc/default/docker中的DOCKER_OPTS 1DOCKER_OPTS='-H fd:// -H tcp://0.0.0.0:2375' 修改/etc/init/docker.conf中的DOCKER_OPTS 网上有人说在Ubuntu14.04上可以生效 123# modify these in /etc/default/$UPSTART_JOB (/etc/default/docker) DOCKERD=/usr/bin/dockerd DOCKER_OPTS='-H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375']]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo搭建自己的博客——创建站点]]></title>
    <url>%2Fpost%2F80ca9385.html</url>
    <content type="text"><![CDATA[安装及配置 简介 Hexo是一个快速、简介且高效的博客框架，可以使用Markdown解析文章并生成网站 说明 站点配置文件 $site_dir/_config.xml 主题配置文件$site_dir/theme/$theme_dir/_config 安装hexo 当环境准备好git以及nodejs后便可以安装hexo 1npm install hexo-cli -g 建站 安装Hexo后，创建站点文件存放的文件夹，如blog，然后执行 123$ hexo init blog$ cd blog$ npm install 完成后，blog目录结构 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 配置 修改_config.yml 123456title: your site tilesubtitle: description: descriptionauthor: your namelanguage: zh-Hanstimezone: Asia/Shanghai 常用命令 清除缓存文件及已生成的静态文件 1$ hexo clean 启动服务器 1$ hexo server 默认状况下，服务器将使用4000端口。可以通过hexo server -p 80来将server绑定至80端口 部署网站 可将网站按照_config.yml中的配置直接部署于github等（后续看心情写步骤） 1$ hexo deploy 主题修改 可访问hexo官方主题库选择自己喜欢的主题，并下载至theme目录下 修改_config.xml中的theme字段 1theme: landscape 写作 有两种方法创建文章 创建文章 hexo命令行方式 1$ hexo new &lt;layout&gt; title layout为模版 命令执行后，默认文章将位于source/_post/目录下，文件内容为： 12345---title: testdate: 2018-03-25 23:10:04tags:--- 直接创建文件 12$ cd source/_post/$ touch myfirstblog.md 此时文件内容为空，需要自己添加相关内容 创建标签页 配置确认 确认站点配置文件中有以下内容 1tag_dir: tags 确认主题配置文件中tags打开 123menu: 主页: / || home 标签: /tags/ || tags 创建标签页 1$ hexo new page tags 修改tags/index.md中的type为&quot;tags&quot; 12345---title: Tagclouddate: 2018-03-23 01:18:00type: "tags"--- 创建分类页面 与创建标签页相似 确认配置 站点配置文件中有category_dir: categories 主题配置文件中的分类: /categories/ || th开启 创建分类也 1$ hexo new page categories]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>markdown</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker基本操作（一）]]></title>
    <url>%2Fpost%2F493f285a.html</url>
    <content type="text"><![CDATA[本文作为docker使用笔记供小伙伴们参考 准备工作 安装最新版的docker-ce，会将自动命令行补齐安装在/usr/share/bash-completion/completions/docker目录 为了方便操作，在ubuntu上打开docker命令行自动补齐功能 编辑/etc/bash.bashrc文件，查找completion段，将该段内容前的#删除即可 12345678# enable bash completion in interactive shellsif ! shopt -oq posix; then if [ -f /usr/share/bash-completion/bash_completion ]; then . /usr/share/bash-completion/bash_completion elif [ -f /etc/bash_completion ]; then . /etc/bash_completion fifi image操作 build image 1$ docker build -t mytest:latest . 查看image 12345$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnginx &lt;none&gt; 73acd1f0cfad 8 days ago 109MBmongo 3 5b1317f8158f 8 days ago 366MB$ dockeer image ls 删除image 12$ docker image rm &lt;id/name&gt;$ docker rmi &lt;id/name&gt; 从docker hub上获取image 国内访问docker hub较慢，可使用阿里云的docker镜像服务 1$ docker pull nginx continer相关 创建docker 1$ docker run -d --name mytest -p 80:80 mynginx 常用参数说明 –rm 当运行结束（当CMD或entrypoint或docker run命令行指定的命令运行结束时，容器停止）时自动删除docker -it 重定向docker终端 -d 在后台执行 -e 添加运行时的参数，常被用于docker CMD执行时增加参数 docker支持长id和短id方式索引，亦可通过名称进行索引 stop/start/restart容器 通过docker stop可以停止运行的容器，也可以使用docker kill来快速停止一个容器 docker start会保留容器的第一次启动时的所有参数 docker restart可以重启容器 可以在启动容器时设置–restart来自动重启容器 删除容器 可以使用docker ps列出当前正在运行的容器 容器停止运行不代表容器已经被删除，可以使用docker ps -a 使用docker rm来删除一个容器 使用docker rmi则会删除docker的image 查看及操作 查看容器状态 123$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES30c8e35f1292 portainer/portainer "/portainer" 10 days ago Up 2 days 0.0.0.0:9000-&gt;9000/tcp clever_murdock 使用docker ps -a查看所有容器（包含休眠状态） 1234$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES30c8e35f1292 portainer/portainer "/portainer" 10 days ago Up 2 days 0.0.0.0:9000-&gt;9000/tcp clever_murdockef58155f9957 registry:2 "/entrypoint.sh /etc…" 2 days ago Exited (137) 41 hours ago sltregistry 连接到容器的终端 尽量使用exec方法，attach连入后可查看当前容器命令运行的日志，但不当的操作容易使运行中的容器退出 使用attach 1$ docker attach &lt;id/name&gt; 使用exec 1$ docker exec -it &lt;id/name&gt; /bin/sh 查看容器运行的日志 容器以-d参数运行时，可以使用docker logs查看运行过程中的日志 123$ docker logs mytest_haproxy[WARNING] 079/100555 (1) : [haproxy.main()] Cannot raise FD limit to 200000011, limit is 1048576.[WARNING] 079/100555 (1) : [haproxy.main()] FD limit (1048576) too low for maxconn=100000000/maxsock=200000011. Please raise 'ulimit-n' to 200000011 or more to avoid any trouble.]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在树莓派上部署nodejs]]></title>
    <url>%2Fpost%2F4fa2931e.html</url>
    <content type="text"><![CDATA[终于有时间在树莓派上部署一个自己的小博客了，平时用惯了ubuntu，到了树莓派上，发现并没有那么简单。首先就是apt install nodejs，安装完没有npm。不过，经过一番折腾，便有了现在的小站点 安装nodejs nodejs可以使用源码编译和二进制包来安装。考虑到树莓派的处理能力，要编译一个nodejs，太过耗时。直接选用官网提供的二进制包完成安装 安装包获取 官网上ARM的bin包有3个，分别是v6，v7和v8。而树莓派的版本是v7 12$ uname -aLinux raspberrypi 4.9.80-v7+ #1098 SMP Fri Mar 9 19:11:42 GMT 2018 armv7l GNU/Linux 获取安装包 1$ wget https://nodejs.org/dist/v8.10.0/node-v8.10.0-linux-armv7l.tar.xz 安装nodejs 解压缩 1234567$ tar -Jxv -f node-v8.10.0-linux-armv7l.tar.xznode-v8.10.0-linux-armv7l/node-v8.10.0-linux-armv7l/README.mdnode-v8.10.0-linux-armv7l/bin/node-v8.10.0-linux-armv7l/bin/nodenode-v8.10.0-linux-armv7l/bin/npm... 可根据个人喜好重命名文件夹，此处重命名为node，分别验证版本信息 1234pi@raspberrypi:~/node $ ./bin/node -vv8.10.0pi@raspberrypi:~/node $ ./bin/npm -v5.6.0 配置node和npm为全局命令 12pi@raspberrypi:~/node $ sudo ln /home/pi/node/bin/node /usr/local/bin/nodepi@raspberrypi:~/node $ sudo ln -s /home/pi/node/lib/node_modules/npm/bin/npm /usr/local/bin/npm 此时执行npm会报错 123456pi@raspberrypi:~/node $ npm -vmodule.js:471 throw err; ^Error: Cannot find module '/usr/local/bin/node_modules/npm/bin/npm-cli.js' 需要修改/usr/local/bin/目录下的npm文件，将$basedir替换为绝对路径，此处为/home/pi/node/ 12345678910111213141516171819202122232425262728293031323334#!/bin/sh(set -o igncr) 2&gt;/dev/null &amp;&amp; set -o igncr; # cygwin encoding fixbasedir=`dirname "$0"`case `uname` in *CYGWIN*) basedir=`cygpath -w "$basedir"`;;esacNODE_EXE="/home/pi/node/bin/node.exe"if ! [ -x "$NODE_EXE" ]; then NODE_EXE=nodefiNPM_CLI_JS="/home/pi/node/lib/node_modules/npm/bin/npm-cli.js"case `uname` in *MINGW*) NPM_PREFIX=`"$NODE_EXE" "$NPM_CLI_JS" prefix -g` NPM_PREFIX_NPM_CLI_JS="$NPM_PREFIX/node_modules/npm/bin/npm-cli.js" if [ -f "$NPM_PREFIX_NPM_CLI_JS" ]; then NPM_CLI_JS="$NPM_PREFIX_NPM_CLI_JS" fi ;; *CYGWIN*) NPM_PREFIX=`"$NODE_EXE" "$NPM_CLI_JS" prefix -g` NPM_PREFIX_NPM_CLI_JS="$NPM_PREFIX/node_modules/npm/bin/npm-cli.js" if [ -f "$NPM_PREFIX_NPM_CLI_JS" ]; then NPM_CLI_JS="$NPM_PREFIX_NPM_CLI_JS" fi ;;esac"$NODE_EXE" "$NPM_CLI_JS" "$@" 再次验证，npm已经可以正常工作]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>nodejs</tag>
        <tag>pi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F4a17b156.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
