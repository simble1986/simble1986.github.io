<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[dockerpty使用]]></title>
    <url>%2Fpost%2F1c49a9aa.html</url>
    <content type="text"><![CDATA[本篇博客将介绍在使用docker API时，如何监管container的PTY实现交互 问题引入 docker官方已经提供了API用来管理client，container，image，network等，基本的操作覆盖了docker CLI相关功能，但docker的API现在只能使用exec_run来执行一条命令，中间无法进行交互，希望能有一个类似于-it的方式来完成交互操作。 经过几天的学习和测试，发现其实docker的containers.run()和containers.exec_run()都是可以设置stdin=True, tty=True。但开启这些之后，将返回一个socket，需要自己来进行处理。 google大法后，找到了一个dockerpty的python lib，可以完成这件事情 环境搭建 根据dockerpty的github上提到的安装过程，只需要pip install dockerpty即可完成安装。 但源码已经有两年没有更新了，该版本无法在新的docker API上正常工作 fork了工程后，对其中的代码涉及到的docker API进行更新后，测试可以正常工作，最新的代码已经上传到git上simble1986/dockerpty 依赖 原有的project上提到依赖的docker api为docker-py&gt;=0.3.2，但docker的python API已经更新 安装docker API 1pip install docker 安装步骤 获取源码 1git clone https://github.com/simble1986/dockerpty.git 安装 123$ pip uninstall dockerpty$ cd dockerpty$ python setup.py install 相关API 参看docker官方API文档，以下主要对container相关参数加以说明 tty (bool) – Allocate a pseudo-TTY. stdin_open (bool) – Keep STDIN open even if not attached. 基本使用 连接client 1234567root@slt-docker:/home/bqi# pythonPython 2.7.12 (default, Dec 4 2017, 14:50:18)[GCC 5.4.0 20160609] on linux2Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; import docker&gt;&gt;&gt; import dockerpty&gt;&gt;&gt; client=docker.from_env() 注： 支持远程API 创建container 1&gt;&gt;&gt; test1 = client.containers.create("ubuntu","/bin/bash",tty=True,stdin_open=True) 使用dockerpty 123456&gt;&gt;&gt; dockerpty.start(client,test1)root@d6ddcf619602:/# lsbin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr varroot@d6ddcf619602:/# exitexit&gt;&gt;&gt;]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>docker</tag>
        <tag>dockerpty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker中无密码apt安装mysql]]></title>
    <url>%2Fpost%2F70cf198a.html</url>
    <content type="text"><![CDATA[问题出现 Linux在第一次安装有些软件时会有交互的输入的需求，比如mysql在首次安装时需要设置root的密码。这在正常配置过程中没什么问题，但在使用DockerFile创建docker镜像时，则遇到了麻烦。 解决思路 如果将安装好的mysql-server使用apt remove从系统中卸载后，再次重新安装，则不再需要输入密码。另外当安装完一些软件后，可以使用dpkg-config来重新配置。 这样，就可以在安装软件前先对系统做好相关配置。接下来，就是需要获取软件的必要配置项 获取软件必要配置项 下载软件包 可以通过网上搜索方式下载相关的deb包，但众所周知，Linux的软件包版本多，很多情况下并不知道需要安装哪个版本。但可以使用apt来下载相应的软件包 1$ apt-get -d install -y mysql-server 使用apt-get的-d参数，将只会下载，不进行安装。下载完毕后，软件包位于/var/cache/apt/archives目录下。 获取配置项 进入软件包的存放目录，然后执行 1dpkg-preconfigure mysql-server-5.1_5.1.49-3_amd64.deb 使用debconfig-show来查看相应的配置项 12345$ debconf-show mysql-server mysql-server/root_password: (password omitted) mysql-server/root_password_again: (password omitted) mysql-server/error_setting_password: ... 可以看到，有两项是必须配置的：mysql-server/root_password和mysql-server/root_password_again 预配置 创建配置文件 在合适的目录下创建一个文件，例如mysql-passwd，输入以下内容 12debconf mysql-server/root_password password 123456debconf mysql-server/root_password_again password 123456 加载配置 1$ debconf-set-selections mysql-passwd 测试结果 再次安装mysql-server，将不再需要输入密码 1$ apt-get install -y mysql-server DockerFile处理 DockerFile应当尽量避免不需要的操作，所以，获取配置项的操作可以提前在实验环境中完成。 可将获取的命令行保存为本地文件，使用时copy过去。 12COPY ./mysql-passwd /tmp/mysql-passwdRUN apt-get update &amp;&amp; debconf-set-selections /tmp/mysql-passwd &amp;&amp; apt-get install -yqq mysql-server &amp;&amp; rm -rf /var/lib/apt/lists/* 或者是在DockerFile中直接生成，这时则可以将mysql passwd设置为参数 12RUN echo debconf mysql-server/root_password password 123456 &gt; /tmp/mysql-passwd &amp;&amp; echo debconf mysql-server/root_password_again password 123456 &gt;&gt; /tmp/mysql-passwdRUN apt-get update &amp;&amp; debconf-set-selections /tmp/mysql-passwd &amp;&amp; apt-get install -yqq mysql-server &amp;&amp; rm -rf /var/lib/apt/lists/*]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>docker</tag>
        <tag>DockerFile</tag>
        <tag>mysql-server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Next上开启Valine评论系统]]></title>
    <url>%2Fpost%2Fa072bce6.html</url>
    <content type="text"><![CDATA[朋友之前问怎么没有开评论系统，倒不是不想开，而是刚开始建站的时候浏览了好多博文，似乎很多原来的接口都在hexo不太好用了。特别是很多博文都是两年前写的，当然，大多数其他功能都没问题 简介 Valine Valine是一款基于Leancloud的快速、简洁且高效的无后端评论系统。 Leancloud 我的理解，Leancloud相当于是一个数据托管平台，可以帮助应用存储相关数据。Valine主要用到的是其中的数据存储——comments 环境说明 使用了最新版的Hexo以及最新版的Next主题 获取AppID 注册Leancloud 访问Leancloud，点击免费试用就会跳转到注册/登陆页面。当前支持通过Github，Weibo以及QQ进行注册 注册完后需要验证邮箱 创建应用 访问控制台，在控制台中创建新应用 获取应用Key 点击新创建的应用——设置——应用Key，保存页面上的App ID以及App Key以备后续使用 配置Valine 在最新版的Next主题中，已经合入了Valine的配置代码，使得配置起来非常快捷。访问Hexo中使用Valine，点击merged，会跳转到Next主题的merge历史 检查相关文件 可以再次检查并确认主题配置文件_config.xml，layout/_macro/post.swig和layout/_third-party/comments/valine.swig是否都已经合入了相关代码 配置AppKey 编辑主题配置文件_config.xml中的valine部分内容 12345678910valine: enable: true appid: $Your APP ID # your leancloud application appid appkey: $Your APP Key # your leancloud application appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: 随便说些什么吧 # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size 重新生成页面 执行命令，重新生成并部署 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 到这里，查看页面已经可以看到评论系统 创建留言页面 可以为站点创建一个单独的留言板页面 创建页面 1$ hexo new page guestbook 配置主题 修改主题配置文件 在主题配置文件_config.xml的menu字段新增guestbook字段 12345678910menu: home: / || home tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat about: /about/ || user guestbook: /guestbook/ || comments 可以访问fontawesome选择自己喜欢的图标来作为留言板的图标 本地化处理 编辑对应语言的配置文件themes/next/languages/zh-CN.yml，在menu中增加guestbook的中文 1234567891011menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益 404 guestbook: 留言 编辑页面 编辑之前生成的guestbook页面 123456---title: 留言板date: 2018-03-26 23:36:19comments: true---&lt;center&gt;既然来了，就是一种缘分，留下点什么吧:cat:&lt;/center&gt; 重新部署之后就可以看到留言板了 😃 清除测试留言 为了确保留言功能已经正常工作，都会测试一下。测试完毕后，可以通过Leancloud的控制台清除测试数据 点击myblog——存储——Comments，即可查看当前留言，选中测试时的留言，删除即可]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>Next</tag>
        <tag>Valine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Ubuntu 16.04上开启Docker的Remote API]]></title>
    <url>%2Fpost%2F3e41aa59.html</url>
    <content type="text"><![CDATA[由于自动化的考虑，需要用docker的remote API，尝试了多种方法，最终才找到了可行的方法 可行的方法 编辑/lib/systemd/system/docker.service 1$ vim /lib/systemd/system/docker.service 修改ExecStart的参数 1ExecStart=/usr/bin/dockerd -H fd:// -H tcp://0.0.0.0:2375 随后执行service docker restart时会提示Warning: docker.service changed on disk. Run 'systemctl daemon-reload' to reload units.则表示配置成功 1systemctl daemon-reload 重启docker服务 1service docker restart 测试是否成功 12$ curl http://localhost:2375/containers/json[&#123;"Id":"30c8e35f1292421d11f6b09385a4fc980d6abaca591d0f52b18dbad8e4f5be04","Names":["/clever_murdock"],"Image":"portainer/portainer","ImageID":"sha256:a8f2aeb34cf69178be1d152759fb17ccff7915faf750c82cd7d1851b12ec7b37","Command":"/portainer","Created":1520845664,"Ports":[&#123;"IP":"0.0.0.0","PrivatePort":9000,"PublicPort":9000,"Type":"tcp"&#125;],"Labels":&#123;&#125;,"State":"running","Status":"Up 13 minutes","HostConfig":&#123;"NetworkMode":"default"&#125;,"NetworkSettings":&#123;"Networks":&#123;"bridge":&#123;"IPAMConfig":null,"Links":null,"Aliases":null,"NetworkID":"78fa057306e70838bab1e18359c86bd8eff7de2285c351784ad951cd7a73f8d1","EndpointID":"e99ca98169320155c8833a8746be7d0e1c8d98186c75fba9d9bf2486367a4e00","Gateway":"172.17.0.1","IPAddress":"172.17.0.2","IPPrefixLen":16,"IPv6Gateway":"","GlobalIPv6Address":"","GlobalIPv6PrefixLen":0,"MacAddress":"02:42:ac:11:00:02","DriverOpts":null&#125;&#125;&#125;,"Mounts":[&#123;"Type":"bind","Source":"/opt/portainer","Destination":"/data","Mode":"","RW":true,"Propagation":"rprivate"&#125;,&#123;"Type":"bind","Source":"/var/run/docker.sock","Destination":"/var/run/docker.sock","Mode":"","RW":true,"Propagation":"rprivate"&#125;]&#125;] 不可行的方法 同时列出在Ubuntu上不可行的方法 修改/etc/default/docker中的DOCKER_OPTS 1DOCKER_OPTS='-H fd:// -H tcp://0.0.0.0:2375' 修改/etc/init/docker.conf中的DOCKER_OPTS 网上有人说在Ubuntu14.04上可以生效 123# modify these in /etc/default/$UPSTART_JOB (/etc/default/docker) DOCKERD=/usr/bin/dockerd DOCKER_OPTS='-H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375']]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo搭建自己的博客——创建站点]]></title>
    <url>%2Fpost%2F80ca9385.html</url>
    <content type="text"><![CDATA[安装及配置 简介 Hexo是一个快速、简介且高效的博客框架，可以使用Markdown解析文章并生成网站 说明 站点配置文件 $site_dir/_config.xml 主题配置文件$site_dir/theme/$theme_dir/_config 安装hexo 当环境准备好git以及nodejs后便可以安装hexo 1npm install hexo-cli -g 建站 安装Hexo后，创建站点文件存放的文件夹，如blog，然后执行 123$ hexo init blog$ cd blog$ npm install 完成后，blog目录结构 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 配置 修改_config.yml 123456title: your site tilesubtitle: description: descriptionauthor: your namelanguage: zh-Hanstimezone: Asia/Shanghai 常用命令 清除缓存文件及已生成的静态文件 1$ hexo clean 启动服务器 1$ hexo server 默认状况下，服务器将使用4000端口。可以通过hexo server -p 80来将server绑定至80端口 部署网站 可将网站按照_config.yml中的配置直接部署于github等（后续看心情写步骤） 1$ hexo deploy 主题修改 可访问hexo官方主题库选择自己喜欢的主题，并下载至theme目录下 修改_config.xml中的theme字段 1theme: landscape 写作 有两种方法创建文章 创建文章 hexo命令行方式 1$ hexo new &lt;layout&gt; title layout为模版 命令执行后，默认文章将位于source/_post/目录下，文件内容为： 12345---title: testdate: 2018-03-25 23:10:04tags:--- 直接创建文件 12$ cd source/_post/$ touch myfirstblog.md 此时文件内容为空，需要自己添加相关内容 创建标签页 配置确认 确认站点配置文件中有以下内容 1tag_dir: tags 确认主题配置文件中tags打开 123menu: 主页: / || home 标签: /tags/ || tags 创建标签页 1$ hexo new page tags 修改tags/index.md中的type为&quot;tags&quot; 12345---title: Tagclouddate: 2018-03-23 01:18:00type: "tags"--- 创建分类页面 与创建标签页相似 确认配置 站点配置文件中有category_dir: categories 主题配置文件中的分类: /categories/ || th开启 创建分类也 1$ hexo new page categories]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker基本操作（一）]]></title>
    <url>%2Fpost%2F493f285a.html</url>
    <content type="text"><![CDATA[本文作为docker使用笔记供小伙伴们参考 准备工作 安装最新版的docker-ce，会将自动命令行补齐安装在/usr/share/bash-completion/completions/docker目录 为了方便操作，在ubuntu上打开docker命令行自动补齐功能 编辑/etc/bash.bashrc文件，查找completion段，将该段内容前的#删除即可 12345678# enable bash completion in interactive shellsif ! shopt -oq posix; then if [ -f /usr/share/bash-completion/bash_completion ]; then . /usr/share/bash-completion/bash_completion elif [ -f /etc/bash_completion ]; then . /etc/bash_completion fifi image操作 build image 1$ docker build -t mytest:latest . 查看image 12345$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnginx &lt;none&gt; 73acd1f0cfad 8 days ago 109MBmongo 3 5b1317f8158f 8 days ago 366MB$ dockeer image ls 删除image 12$ docker image rm &lt;id/name&gt;$ docker rmi &lt;id/name&gt; 从docker hub上获取image 国内访问docker hub较慢，可使用阿里云的docker镜像服务 1$ docker pull nginx continer相关 创建docker 1$ docker run -d --name mytest -p 80:80 mynginx 常用参数说明 –rm 当运行结束（当CMD或entrypoint或docker run命令行指定的命令运行结束时，容器停止）时自动删除docker -it 重定向docker终端 -d 在后台执行 -e 添加运行时的参数，常被用于docker CMD执行时增加参数 docker支持长id和短id方式索引，亦可通过名称进行索引 stop/start/restart容器 通过docker stop可以停止运行的容器，也可以使用docker kill来快速停止一个容器 docker start会保留容器的第一次启动时的所有参数 docker restart可以重启容器 可以在启动容器时设置–restart来自动重启容器 删除容器 可以使用docker ps列出当前正在运行的容器 容器停止运行不代表容器已经被删除，可以使用docker ps -a 使用docker rm来删除一个容器 使用docker rmi则会删除docker的image 查看及操作 查看容器状态 123$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES30c8e35f1292 portainer/portainer "/portainer" 10 days ago Up 2 days 0.0.0.0:9000-&gt;9000/tcp clever_murdock 使用docker ps -a查看所有容器（包含休眠状态） 1234$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES30c8e35f1292 portainer/portainer "/portainer" 10 days ago Up 2 days 0.0.0.0:9000-&gt;9000/tcp clever_murdockef58155f9957 registry:2 "/entrypoint.sh /etc…" 2 days ago Exited (137) 41 hours ago sltregistry 连接到容器的终端 尽量使用exec方法，attach连入后可查看当前容器命令运行的日志，但不当的操作容易使运行中的容器退出 使用attach 1$ docker attach &lt;id/name&gt; 使用exec 1$ docker exec -it &lt;id/name&gt; /bin/sh 查看容器运行的日志 容器以-d参数运行时，可以使用docker logs查看运行过程中的日志 123$ docker logs mytest_haproxy[WARNING] 079/100555 (1) : [haproxy.main()] Cannot raise FD limit to 200000011, limit is 1048576.[WARNING] 079/100555 (1) : [haproxy.main()] FD limit (1048576) too low for maxconn=100000000/maxsock=200000011. Please raise 'ulimit-n' to 200000011 or more to avoid any trouble.]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在树莓派上部署nodejs]]></title>
    <url>%2Fpost%2F4fa2931e.html</url>
    <content type="text"><![CDATA[终于有时间在树莓派上部署一个自己的小博客了，平时用惯了ubuntu，到了树莓派上，发现并没有那么简单。首先就是apt install nodejs，安装完没有npm。不过，经过一番折腾，便有了现在的小站点 安装nodejs nodejs可以使用源码编译和二进制包来安装。考虑到树莓派的处理能力，要编译一个nodejs，太过耗时。直接选用官网提供的二进制包完成安装 安装包获取 官网上ARM的bin包有3个，分别是v6，v7和v8。而树莓派的版本是v7 12$ uname -aLinux raspberrypi 4.9.80-v7+ #1098 SMP Fri Mar 9 19:11:42 GMT 2018 armv7l GNU/Linux 获取安装包 1$ wget https://nodejs.org/dist/v8.10.0/node-v8.10.0-linux-armv7l.tar.xz 安装nodejs 解压缩 1234567$ tar -Jxv -f node-v8.10.0-linux-armv7l.tar.xznode-v8.10.0-linux-armv7l/node-v8.10.0-linux-armv7l/README.mdnode-v8.10.0-linux-armv7l/bin/node-v8.10.0-linux-armv7l/bin/nodenode-v8.10.0-linux-armv7l/bin/npm... 可根据个人喜好重命名文件夹，此处重命名为node，分别验证版本信息 1234pi@raspberrypi:~/node $ ./bin/node -vv8.10.0pi@raspberrypi:~/node $ ./bin/npm -v5.6.0 配置node和npm为全局命令 12pi@raspberrypi:~/node $ sudo ln /home/pi/node/bin/node /usr/local/bin/nodepi@raspberrypi:~/node $ sudo ln -s /home/pi/node/lib/node_modules/npm/bin/npm /usr/local/bin/npm 此时执行npm会报错 123456pi@raspberrypi:~/node $ npm -vmodule.js:471 throw err; ^Error: Cannot find module '/usr/local/bin/node_modules/npm/bin/npm-cli.js' 需要修改/usr/local/bin/目录下的npm文件，将$basedir替换为绝对路径，此处为/home/pi/node/ 12345678910111213141516171819202122232425262728293031323334#!/bin/sh(set -o igncr) 2&gt;/dev/null &amp;&amp; set -o igncr; # cygwin encoding fixbasedir=`dirname "$0"`case `uname` in *CYGWIN*) basedir=`cygpath -w "$basedir"`;;esacNODE_EXE="/home/pi/node/bin/node.exe"if ! [ -x "$NODE_EXE" ]; then NODE_EXE=nodefiNPM_CLI_JS="/home/pi/node/lib/node_modules/npm/bin/npm-cli.js"case `uname` in *MINGW*) NPM_PREFIX=`"$NODE_EXE" "$NPM_CLI_JS" prefix -g` NPM_PREFIX_NPM_CLI_JS="$NPM_PREFIX/node_modules/npm/bin/npm-cli.js" if [ -f "$NPM_PREFIX_NPM_CLI_JS" ]; then NPM_CLI_JS="$NPM_PREFIX_NPM_CLI_JS" fi ;; *CYGWIN*) NPM_PREFIX=`"$NODE_EXE" "$NPM_CLI_JS" prefix -g` NPM_PREFIX_NPM_CLI_JS="$NPM_PREFIX/node_modules/npm/bin/npm-cli.js" if [ -f "$NPM_PREFIX_NPM_CLI_JS" ]; then NPM_CLI_JS="$NPM_PREFIX_NPM_CLI_JS" fi ;;esac"$NODE_EXE" "$NPM_CLI_JS" "$@" 再次验证，npm已经可以正常工作]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>nodejs</tag>
        <tag>pi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F4a17b156.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
